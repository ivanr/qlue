<?xml version="1.0" encoding="UTF-8"?>
<?oxygen RNGSchema="http://www.oasis-open.org/docbook/xml/5.0/rng/docbook.rng" type="xml"?>
<article xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink"
    version="5.0">
    <info>
        <title>Qlue Reference Manual</title>
        <author>
            <personname>Ivan Ristic</personname>
            <email>ivanr@webkreator.com</email>
        </author>
    </info>
    <section>
        <title>WARNING</title>
        <para>This manual does not currently
            describe the code base accurately.</para>
    </section>
    <section>
        <title>Introduction</title>
        <para>Qlue is a minimalistic web application framework that focuses on simplicity and ease
            of use:</para>
        <itemizedlist>
            <listitem>
                <para>The basic unit of work is a page (subclass of <literal>Page</literal>), which
                    maps to one site page (or URL).</para>
            </listitem>
            <listitem>
                <para>A request is mapped to a page during the mapping phase.</para>
            </listitem>
            <listitem>
                <para>By default, a new page instance is created for every request, allowing for a
                    programming model that avoids concurrency issues.</para>
            </listitem>
            <listitem>
                <para>Processes that span multiple requests are modelled with persistent pages,
                    which are subclasses of <literal>FormPage</literal>. Persistent pages come with
                    CSRF defence built-in.</para>
            </listitem>
            <listitem>
                <para>The framework supports safe parameter binding and input validation, which maps
                    request parameters to annotated class fields.</para>
            </listitem>
            <listitem>
                <para>The Velocity scripting language is used for output generation. Context-aware
                    output encoding was added to Velocity to transparently handle all data as it is
                    sent to output.</para>
            </listitem>
        </itemizedlist>
    </section>
    <section>
        <title>Getting Started</title>
        <para>[...]</para>
        <section>
            <title>Configuration</title>
            <para>[...]</para>
            <programlisting>&lt;?xml version="1.0" encoding="ISO-8859-1"?>
&lt;web-app xmlns="http://java.sun.com/xml/ns/j2ee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://java.sun.com/xml/ns/j2ee/web-app_3_0.xsd"
	version="3.0">

	&lt;context-param>
		&lt;param-name>QLUE_CHARACTER_ENCODING&lt;/param-name>
		&lt;param-value>UTF-8&lt;/param-value>
	&lt;/context-param>

	&lt;context-param>
		&lt;param-name>QLUE_DEVELOPMENT_MODE&lt;/param-name>
		&lt;param-value>1&lt;/param-value>
	&lt;/context-param>

	&lt;filter>
		&lt;filter-name>WelcomeFilter&lt;/filter-name>
		&lt;filter-class>
			com.webkreator.qlue.util.WelcomeFilter
		&lt;/filter-class>
		&lt;init-param>
			&lt;param-name>welcome&lt;/param-name>
			&lt;param-value>index.html&lt;/param-value>
		&lt;/init-param>
	&lt;/filter>

	&lt;filter-mapping>
		&lt;filter-name>WelcomeFilter&lt;/filter-name>
		&lt;url-pattern>/*&lt;/url-pattern>
	&lt;/filter-mapping>

	&lt;listener>
		&lt;listener-class>
			com.webkreator.qlue.util.Log4jConfigListener
		&lt;/listener-class>
	&lt;/listener>

	&lt;servlet>
		&lt;servlet-name>QlueServlet&lt;/servlet-name>
		&lt;servlet-class>
			com.webkreator.qlue.QlueSpringServlet
		&lt;/servlet-class>
		&lt;load-on-startup>1&lt;/load-on-startup>
	&lt;/servlet>

	&lt;servlet-mapping>
		&lt;servlet-name>QlueServlet&lt;/servlet-name>
		&lt;url-pattern>*.html&lt;/url-pattern>
	&lt;/servlet-mapping>

	&lt;error-page>
		&lt;error-code>500&lt;/error-code>
		&lt;location>/_qlue/handleInternalServerError.html&lt;/location>
	&lt;/error-page>

	&lt;error-page>
		&lt;error-code>404&lt;/error-code>
		&lt;location>/_qlue/handlePageNotFound.html&lt;/location>
	&lt;/error-page>

	&lt;error-page>
		&lt;exception-type>java.lang.Throwable&lt;/exception-type>
		&lt;location>/_qlue/handleThrowable.html&lt;/location>
	&lt;/error-page>

	&lt;session-config>
		&lt;session-timeout>15&lt;/session-timeout>

		&lt;tracking-mode>COOKIE&lt;/tracking-mode>

		&lt;cookie-config>
			&lt;secure>true&lt;/secure>
			&lt;http-only>true&lt;/http-only>
		&lt;/cookie-config>
	&lt;/session-config>

&lt;/web-app></programlisting>
        </section>
        <section>
            <title>Hello World</title>
            <para>You create a new page by extending the <literal>Page</literal> class and
                implementing the <literal>onGet()</literal> method:</para>
            <programlisting>public class helloWorld1 extends Page {

	@Override
	public View onGet() throws Exception {
        // Set Content-Type
        context.getResponse().setContentType("text/plain");

        // Write to output
		PrintWriter out = context.response.getWriter();
		out.println("Hello World!");

        // Send null to indicate we've handled the output ourselves
		return null;
	}
}</programlisting>
            <note>
                <para>The class name in the example does not follow Java naming standards because,
                    in the default implementation, class names are directly exposed as URLs. Page
                    names should appear as you want them to appear to web site users.</para>
            </note>
            <para>In the previous example we create output directly by writing to the
                    <literal>PrintWriter</literal> instance we obtain from the page context. The
                return of <literal>null</literal> at the end of the <literal>onGet()</literal>
                method indicated that the page has completely processed the request, and that no
                further work is needed.</para>
        </section>
        <section>
            <title>Using Templates</title>
            <para>More often than not, your pages will focus on implementing the controller logic
                (the C in MVC), forwarding control to a <literal>View</literal> instance to produce
                output (the V in MVC). Such separation of concerns makes applicatoins more elegant,
                increases robustness and makes maintenance easier.</para>
            <para>In the simplest case, a page can return an instance of
                    <literal>DefaultView()</literal>:</para>
            <programlisting>public class helloWorld2 extends Page {

	@Override
	public View onGet() throws Exception {
		return new DefaultView();
	}
}</programlisting>
            <para>The <literal>DefaultView</literal> class will find the template to be used for
                view generation by looking at the URL that the page is processing. For example, if
                the URL is <literal>/addUser.html</literal>, the template named
                    <literal>/addUser.vm</literal> will be used. To complete the page, you also need
                to create the template file (<filename>/addUser.vm</filename>) with the following
                content:</para>
            <programlisting>Hello World!</programlisting>
            <para>If a page desires to use some other template, it returns an instance of the
                    <literal>NamedView</literal> class:</para>
            <programlisting>public class helloWorld4 extends Page {

	@Override
	public View onGet() throws Exception {
		return new NamedView("/helloWorld");
	}
}</programlisting>
            <para>The <literal>NamedView</literal> instance is initialised using the view name.
                Observe the following:</para>
            <itemizedlist>
                <listitem>
                    <para>Do not append the <filename>.vm</filename> extension to the name of the
                        view</para>
                </listitem>
                <listitem>
                    <para>If the view name is relative, it will be resolved against the folder in
                        which the page resides</para>
                </listitem>
                <listitem>
                    <para>If the view name is absolute, it will be resolved against the root folder
                        of the application</para>
                </listitem>
            </itemizedlist>
        </section>
        <section>
            <title>Redirection</title>
            <para>To redirect client to some other URL, return an instance of
                    <literal>RedirectView</literal>:</para>
            <programlisting>public class redirectPage extends Page {

    @Override
    public View onGet() throws Exception {
        RedirectView rv = new RedirectView("/index.html");
        rv.addParam("name", "Ivan");
        return rv;
    }
}</programlisting>
            <para>Do not use string concatenation to add parameters to the redirection string. Use
                the <literal>RedirectView</literal> methods instead, which will ensure that the
                parameters are correctly encoded.</para>
        </section>
        <section>
            <title>Implementing methods other than GET</title>
            <para>All the examples you saw so far assumed pages would only respond to GET (and,
                implicitly, HEAD). The default request method dispatch mechanism only knows how to
                handle GET, HEAD, and POST request methods:</para>
            <itemizedlist>
                <listitem>
                    <para>To respond to a POST requests, override <filename>onPost()</filename>. The
                        default implementation of <filename>onPost()</filename> throws a 405 status
                        code.</para>
                </listitem>
                <listitem>
                    <para>To respond to any request method, override the
                            <filename>service()</filename> method. In this case you need to make
                        sure that you handle all the request methods you wish to handle, but that
                        you also need to throw <filename>RequestMethodException</filename> when you
                        encounter a method you do not wish to handle.</para>
                </listitem>
            </itemizedlist>
        </section>
        <section>
            <title>Importing Request Parameters</title>
            <para>The recommended approach in Qlue is to process request parameters using the
                built-in parameter binding, validation, and transformation. It uses annotations to
                point out the page class fields that need to be populated from request parameters,
                and to specify how that's done. For example:</para>
            <programlisting>public class helloStranger1 extends Page {

    @QlueParameter
	public String username;
}</programlisting>
            <para>The <literal>@QlueParameter</literal> annotation is all that is needed to place
                the request parameter <literal>username</literal> into the field
                    <literal>username</literal>.</para>
            <para>For an example that shows all input validation features, consider the
                following:</para>
            <programlisting>public class helloStranger2 extends Page {

    @QlueParameter(mandatory = true, maxSize = 10, pattern = "^[a-z]+$", tfn="trim,lowercase")
	public String username;
}</programlisting>
            <para>From left to right, the annotation will do the following:</para>
            <orderedlist>
                <listitem>
                    <para>Make the parameter mandatory; an error will occur if the parameter is not
                        present.</para>
                </listitem>
                <listitem>
                    <para>Limit the parameter size; an error will occur if the parameter is longer
                        than 10 characters.</para>
                </listitem>
                <listitem>
                    <para>Make sure that parameter value matches the supplied regular
                        expression.</para>
                </listitem>
                <listitem>
                    <para>Transform the parameter by applying the <literal>trim</literal> function,
                        followed by the <literal>lowercase</literal> function.</para>
                </listitem>
            </orderedlist>
            <note>
                <para>If you need direct access to request parameters, you can get them from
                        <literal>HttpServletRequest</literal> directly, which you can obtain using
                        <literal>getContext().getRequest()</literal>.</para>
            </note>
        </section>
        <section>
            <title>Using a command object</title>
            <para>Although in some cases it is convenient to bind request parameters directly to
                page fields, sometimes you will need more flexibility. A page can specify any object
                to serve as a command object, in which case request parameters will be bound to it.
                To specify a command object, a page needs to override the
                    <literal>determineCommandObject()</literal>:</para>
            <programlisting>public class commandObject extends Page {

    @Override
    public Object determineCommandObject() {
        return new MyCommandObject();
    }

    @Override
    public View onGet() {
        return new DefaultView();
    }
}</programlisting>
        </section>
        <section>
            <title>Adding your own property editors</title>
            <para>Qlue implements only a small number of property editors. At the moment, it
                supports the conversion for the following classes:</para>
            <itemizedlist>
                <listitem>
                    <para><literal>Boolean</literal></para>
                </listitem>
                <listitem>
                    <para><literal>Integer</literal></para>
                </listitem>
                <listitem>
                    <para><literal>String</literal></para>
                </listitem>
            </itemizedlist>
            <para>To support conversions of other classes you need to add your own property editors.
                To register a new property editor, override the method
                    <literal>initPropertyEditors()</literal> in your application:</para>
            <programlisting>public class MyApplication extends QlueApplication {

    @Override
    public void initPropertyEditors() {
        // Initialize default property editors
        super();

        // Now add your own editors
        registerEditor(new SomeClassEditor());
    }
}</programlisting>
            <para>The <literal>SomeClassEditor</literal> class must implement the
                    <literal>PropertyEditor</literal> interface. Examine the
                    <literal>BooleanEditor</literal> class for an example:</para>
            <programlisting>public class BooleanEditor implements PropertyEditor {

	@Override
	public Boolean fromText(Field field, String text) {		
		return Boolean.valueOf(text);
	}
	
	@Override
	public Class getEditorClass() {		
		return Boolean.class;
	}
}</programlisting>
        </section>
        <section>
            <title>Retrieving original parameter values</title>
            <para>Parameter binding is a very useful feature, but it will only bind parameters to
                the command objects when conversion is possible. Qlue keeps the original request
                parameter values as <firstterm>shadow input</firstterm>. Shadow input is an
                    <literal>ShadowInput</literal> instance that you obtain by calling
                    <literal>page.getShadowInstance()</literal>. Only the annotated command object
                fields will be stored in shadow input.</para>
        </section>
        <section>
            <title>Handling validation errors</title>
            <para>Parameter validation shields your code from invalid input, but you also need to
                decide what to do when validation fails. A page's entry point will not be invoked
                when a validation error occurs. If you choose not to do anything about the errors. a
                    <literal>ValidationException</literal> instance will be thrown. By default, that
                will cause Qlue to display its <emphasis>Parameter Validation Failed</emphasis>
                page.</para>
            <para>To handle errors, override the <literal>onError()</literal> method in your page.
                Similarly to <literal>service()</literal>, <literal>onGet()</literal>, and
                    <literal>onPost()</literal>, <literal>onError()</literal> is expected to handle
                output directly or return a <literal>View</literal> instance. Do not forget that
                    <literal>onError()</literal> will be invoked for any request method your page
                would accept to handle. For example, in a page that only responds to GET requests,
                    <literal>onError()</literal> will only ever see a GET, but in a page that
                responds to GET and POST requests methods, <literal>onError()</literal> may see
                either one.</para>
        </section>
        <section>
            <title>Using data in output</title>
            <para>A number of objects will be automatically exposed by the framework, making them
                available to use from Velocity. These objects, whose names always begin with an
                underscore, are documented in XXX.</para>
            <table frame="none">
                <title/>
                <tgroup cols="2">
                    <colspec colname="c1" colnum="1"/>
                    <colspec colname="c2" colnum="2"/>
                    <thead>
                        <row>
                            <entry>Header 1</entry>
                            <entry>Header 2</entry>
                        </row>
                    </thead>
                    <tbody>
                        <row>
                            <entry><literal>_app</literal></entry>
                            <entry>Application object</entry>
                        </row>
                        <row>
                            <entry><literal>_cmd</literal></entry>
                            <entry>Command object (the page itself, by default)</entry>
                        </row>
                        <row>
                            <entry><literal>_ctx</literal></entry>
                            <entry>Context object</entry>
                        </row>
                        <row>
                            <entry><literal>_errors</literal></entry>
                            <entry>List of validation errors, if any</entry>
                        </row>
                        <row>
                            <entry><literal>_f</literal></entry>
                            <entry>Formatting helper</entry>
                        </row>
                        <row>
                            <entry><literal>_i</literal></entry>
                            <entry>Shadow input</entry>
                        </row>
                        <row>
                            <entry><literal>_page</literal></entry>
                            <entry>Page object</entry>
                        </row>
                        <row>
                            <entry><literal>_req</literal></entry>
                            <entry>Request object</entry>
                        </row>
                        <row>
                            <entry><literal>_res</literal></entry>
                            <entry>Response object</entry>
                        </row>
                    </tbody>
                </tgroup>
            </table>
            <para>The public fields of the command object are exposed as Velocity objects, under the
                same names.</para>
            <para>Pages can expose any objects they choose by adding them to the map returned by
                    <literal>getModel()</literal>. You are advised not to use any names that begin
                with underscores, to avoid potential clashes with the built-in objects. Also, the
                addition of command object fields is doing just prior to view rendering, which means
                that any fields that have the same name as the manually added objects will be
                overwritten.</para>
        </section>
        <section>
            <title>Development Mode</title>
            <para>Development mode in Qlue is a way of providing more information to developers when
                errors occur. In production mode (the default), an error will cause an error message
                to be displayed, but little information will be provided to prevent information
                leakage. In development mode, Qlue will provide all the information it has on an
                error.</para>
            <para>Development mode is controlled using the <literal>QLUE_DEVMODE_ENABLED</literal>
                configuration parameter, which has three settings:</para>
            <variablelist>
                <varlistentry>
                    <term>Off</term>
                    <listitem>
                        <para>Development mode is disabled.</para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>On</term>
                    <listitem>
                        <para>Development mode is enabled. Additional information will be provided
                            to those accessing the application from the allowed IP addresses.</para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>OnDemand</term>
                    <listitem>
                        <para>Development mode is disabled by default, but can be enabled by
                            developers, on per-session basis, provided the correct password is
                            entered and access is from one of the allowed IP addresses.</para>
                    </listitem>
                </varlistentry>
            </variablelist>
            <para>As an additional security measure, development mode will only be enabled for the
                IP addresses specified in the <literal>QLUE_DEVMODE_RANGES</literal> configurtation
                parameter.</para>
            <section>
                <title>Per-Session Development Mode</title>
                <para>Per-session development mode is useful in the cases when developers share
                    their IP address (at least from the point of view of the application) with
                    others. To enable per-session development mode, the following three requirements
                    must be fulfilled:</para>
                <itemizedlist>
                    <listitem>
                        <para>The <literal>QLUE_DEVMODE_ENABLED</literal> configuration parameter is
                            set to OnDemand.</para>
                    </listitem>
                    <listitem>
                        <para>Developer is behind one of the IP addresses specified in
                                <literal>QLUE_DEVMODE_RANGES</literal></para>
                    </listitem>
                    <listitem>
                        <para>Developer explicitly requests development mode and provides a password
                            that matches that configured in
                            <literal>QLUE_DEVMODE_PASSWORD</literal></para>
                    </listitem>
                </itemizedlist>
                <para>In any application, the form to enable development mode can be reached using
                    the following URL:</para>
                <simplelist>
                    <member>/_qlue/devMode.html</member>
                </simplelist>
                <para>To disable development mode, developer should close the browser instance or
                    visit the form page again.</para>
            </section>
        </section>
    </section>
    <section>
        <title>Implementing Forms</title>
        <para>In Qlue, forms are implemented with pages that extend <literal>FormPage</literal>. The
            idea is that forms generally need state to be implemented correctly. Qlue will handle
            most of the added complexity involved, leaving you only with the task of managing the
            state itself.</para>
        <para>Form pages begin their life stateless, like other pages. A new instance of a form page
            will be created whenever the GET method is invoked and the URI is matched to a form
            page. However, when a form page encounters the POST method, it will become persistent
            and stored in the current user's session storage. From that moment the form page will
            remain persistent until it finishes with its work, or until it is garbage collected
            because it was abandoned by the user.</para>
        <para>Let's examine a simple form page:</para>
        <programlisting/>
        <para>Let's now examine a typical form page's lifecycle; You invoke the page initially by
            navigating to an URL such as <filename>/formExample.html</filename>:</para>
        <orderedlist>
            <listitem>
                <para>Your browsers sends a GET request, which Qlue will be map to the appropriate
                    page.</para>
            </listitem>
            <listitem>
                <para>The form page is processed as a normal, non-persistent page: a new instance is
                    created to produce output; the instance is then left for garbage collection by
                    the JVM. It will not be used again.</para>
            </listitem>
            <listitem>
                <para>Our example form page displays an empty form. The only interesting thing at
                    this point is the nonce, which is embedded in the form through a hidden field.
                    You can see if if you view the source of the resulting page.</para>
            </listitem>
        </orderedlist>
        <para>Once you press the submit button, things are handled differently:</para>
        <orderedlist>
            <listitem>
                <para>Your browser sends a POST request to the same URL.</para>
            </listitem>
            <listitem>
                <para>A new instance of the form page is created.</para>
            </listitem>
            <listitem>
                <para>Seeing the POST, Qlue makes the page persistent by storing it in session
                    storage. The same page instance will handle all subsequent requests.</para>
            </listitem>
            <listitem>
                <para>Behind the scenes, the form page will verify that the nonce supplied with the
                    POST request matches the nonce in the session storage. This is done in the
                    default implementation of <literal>FormPage.preService()</literal>.</para>
            </listitem>
            <listitem>
                <para>By the default, the state of the form page will change from
                        <literal>NEW</literal> to <literal>SUBMIT</literal>. This is done in the
                    default implementation of <literal>FormPage.updateState()</literal>.</para>
            </listitem>
            <listitem>
                <para>Parameter binding takes place.</para>
            </listitem>
            <listitem>
                <para>The <literal>onPost()</literal> method is now invoked to process the request.
                    Unlike with non-persistent page, the <literal>onError()</literal> method is
                    never invoked. The assumption is that form pages will check if there were any
                    validation errors raised by Qlue before performing any actions. Many forms will
                    perform further validation even in the presence of earlier errors, in order to
                    return the complete list of error messages to the user.</para>
            </listitem>
            <listitem>
                <para>Assuming the work is not yet done, the page will return a redirection to
                    itself (<literal>new RedirectView(this)</literal>), which will issue a
                    redirection to the persistent page's URL. The persistent page's URL is identical
                    to the original URL that started the process, but it has only one the parameter
                        <literal>_pid</literal>, which contains the unique ID of the persistent
                    page. That is how Qlue will know how to locate the persistent page on subsequent
                    requests.</para>
            </listitem>
        </orderedlist>
        <para>The POST-GET cycle can continue for as long as it's necessary for the form page to
            complete its work. When that happens, the persistent page needs to release any resources
            it is hold (e.g., temporary files or remote connections) and return an instance of
                <literal>FinalRedirectView</literal>. The state will then change to
                <literal>FINISHED</literal>.</para>
    </section>
</article>
